---
title: "Aula 2"
author: "Carolene Bertoldi"
date: "2 de junho de 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Exerc√≠cio de revis√£o ‚Äì Aula 01 A

Criar 6 vetores:

1. Vetor *a*ùëé de inteiros com 5 n√∫meros:
   N√∫mero da matr√≠cula na FIAP (sem letras)
   Data de nascimento, formato yyyyMMdd
   3 √∫ltimos d√≠gitos do seu CPF
   6 primeiros d√≠gitos do RG
   4 d√≠gitos da placa do carro (pode inventar)

2. Vetor *b*ùëè com o dobro do vetor ùëé

3. Vetor *c* com $\frac{b}{3}$

4. Vetor *d* com $c + a^2$

5. Vetor *e* com $\sqrt{d}$

6. Criar vetor *ai* com o inverso de *a*

```{r exercicio1}
a = c(330509, 19910802, 523, 587817, 1234)

b = a * 2

c = b / 3

d = c + a**2

e = sqrt(d)

ai = a[5:1]
```

## Exerc√≠cio de revis√£o ‚Äì Aula 01 B

Criar matrizes:

ùëÄ1. *M1* 6√ó5 com cada linha contendo o valor de um dos vetores
ùëÄ2. *M2* 5√ó6 com cada coluna contendo o valor de um dos vetores
ùëÄ3. *M3* 6√ó5 com cada elemento contendo 10% de ùëÄ1 , ou seja, *M1* √ó 0,1
4.  Criar matriz *M4* 5√ó6 sendo uma tabela com 5 linhas e 6 colunas quaisquer de *attitude*

```{r exercicio2}
M1 = matrix(c(a ,b ,c ,d ,e , ai), nrow = 6, byrow = T)

M2 = matrix(c(a ,b ,c ,d ,e , ai), nrow = 5)

M3 = M1 * 0.1

M4 = as.matrix(attitude[25:29, 2:7])
```


## Exerc√≠cios de soma e subtra√ß√£o em matrizes

1. Criar matriz (in memory) 19x19 com os valores 1 e 2 nos elementos, alternadamente.
2. Somar 1 para cada elemento da linha 1, 2 na linha 2,... e 19 na linha 19.
3. Somar 1 para cada elemento da linha 1, 2 na linha 2,... e 19 na linha 19.

```{r exercicio3}
M19 = matrix(1:2, nrow = 19, ncol = 19)

M19_1 = M19 - 1

M19_2 = M19 + 1:19
```

## Exerc√≠cio multiplica√ß√£o de matrizes

1. *M5* com cada elemento sendo a a multiplica√ß√£o do elemento equivalente das matrizez *M1* e *M3*. 2. *M6* com cada elemento sendo a a multiplica√ß√£o do elemento equivalente das matrizez *M3* e *M1*.
3. Criar matriz *M7* com a multiplica√ß√£o das matrizes *M1* e *M4*.
4. Criar matriz *M8* com a multiplica√ß√£o das matrizes *M4* e *M1*.

```{r exercicio4}
M5 = M1 * M3
M6 = M3 * M1
M7 = M1 %*% M4
M8 = M4 %*% M1

M5 == M6
#M7 == M8
```

### Resposta para as compara√ß√µes entre as matrizes M5 e M6, e as matrizes M7 e M8.

As matrizes **M5** e **M6** s√£o matrizes id√™nticas pois foram geradas a partir da multiplica√ß√£o dos elementos da primeira matrizes pelo elemento na posi√ß√£o equivalente na segunda matriz, e neste caso a multiplica√ß√£o √© comutativa.
J√° as matrizes **M7** e **M8** foram geradas a partir da multiplica√ß√£o de matrizes que segue uma regra particular em que cada elemento √© gerado pelo somada dos produtos dos elementos de cada linha da primeira matriz pela coluna da segunda matriz, gerando uma matriz resultante com numero de linhas da primeira matriz e o n√∫mero de colunas da segunda. E como a multiplica√ß√£o de matrizes n√£o √© comutativa, foram geradas a **M7** com 6 linhas e 6 colunas e **M8** com 5 linhas e 5 colunas. Portanto matrizes com estruturas diferentes imposs√≠vel de ser comparadas.

## Exerc√≠cio matriz transposta

1. Obter a transposta *M1T*ùëá a *M8T*ùëá de cada uma das matrizes *M1* a *M8*
2. Comparar a multiplica√ß√£o
   *M8* X *M8T*
   *M8T* X *M8*

```{r exercicio5}

M1T = t(M1)
M2T = t(M2)
M3T = t(M3)
M4T = t(M4)
M5T = t(M5)
M6T = t(M6)
M7T = t(M7)
M8T = t(M8)

M8 %*% M8T == M8T %*% M8
```
### Resposta para as compara√ß√µes entre as multiplica√ß√µes da matriz M8 pela sua transposta e vice-versa.

Neste caso foi poss√≠vel comparar as multiplica√ß√µes pois a M8 possui o mesmo numero de linhas e colunas, e logicamente sua transposta tamb√©m. Por√©m na compara√ß√£o dos elementos gerados podemos perceber que foram obtidos resultados diferentes nas opera√ß√µes de multiplica√ß√£o de matrizes, evid√™nciando novamente a sua n√£o comutatividade.

## Exerc√≠cio malvad√£o com matrizes

Obter o valor da matriz X na equa√ß√£o:
  AX = B
  onde,
  `A = as.matrix( attitude[21:25, 1:5] )`
  `B = as.matrix( attitude[11:15, 1:5] )`
  
```{r exercicio6}
A = as.matrix( attitude[21:25, 1:5] )
B = as.matrix( attitude[11:15, 1:5] )

X = solve(A) %*% B
```
  
### Explica√ß√£o da resposta

Em matrizes a multiplica√ß√£o de uma matriz pela sua inversa resulta em uma matriz denominada matriz identidade **I**, que  √© considerada um elemento neutro em opera√ß√µes entre matrizes, como n√∫mero 0 √© para a adi√ß√£o e o n√∫mero 1 √© para a multiplica√ß√£o. 
Assim sendo se multiplicarmos ambos os termos da equa√ß√£o pela inversa de A, teriamos, anulariamos A no primeiro termo e obtemos X atrav√©s da multiplica√ß√£ matricial entre a inversa de A e B.

## Exerc√≠cios RMarkdown - 01

Criar um arquivo .Rmd
Configurar output para html ou notebook (que √© html)

1. Chunk com todo o conte√∫do da tabela ‚Äòcars‚Äô
2. Chunk com 5 primeiras linhas da tabela ‚Äòcars‚Äô
3. Chunk com 5 √∫ltimas linhas da tabela ‚Äòcars‚Äô
4. Chunk com o resumo da tabela ‚Äòcars‚Äô
5. Chunk com plot simples da tabela ‚Äòcars‚Äô
6. Texto explicativo antes de cada chunk
  
Exibindo dados do dataset *cars*
```{r exercicio71}
cars
```

Exibindo primeiras cinco linhas do dataset *cars*
```{r exercicio72}
head(cars, 5)
```

Exibindo √∫ltimas cinco linhas do dataset *cars*
```{r exercicio73}
tail(cars, 5)
```

Resumo sobre o dataset *cars*
```{r exercicio74}
summary(cars)
```

Plot do dataset *cars*
```{r exercicio75}
plot(cars)
```

## Exerc√≠cios sobre Special Values

1. Criar 5 vari√°veis. Cada uma com um tipo dos valores especiais (+Inf e ‚ÄìInf)
2. Tentar criar um vetor com as 5 vari√°veis.
   Foi poss√≠vel?
3. Verificar os valores das vari√°veis e vetor atrav√©s das fun√ß√µes

```{r exercicio8}
v1 = NA
v2 = NaN
v3 = NULL
v4 = Inf
v5 = -Inf

vall = c(v1, v2, v3, v4, v5)

#V1
is.na(v1)
is.nan(v1)
is.null(v1)
is.infinite(v1)
is.finite(v1)

#V2
is.na(v2)
is.nan(v2)
is.null(v2)
is.infinite(v2)
is.finite(v2)

#V3
is.na(v3)
is.nan(v3)
is.null(v3)
is.infinite(v3)
is.finite(v3)

#V4
is.na(v4)
is.nan(v4)
is.null(v4)
is.infinite(v4)
is.finite(v4)

#V5
is.na(v5)
is.nan(v5)
is.null(v5)
is.infinite(v5)
is.finite(v5)

#Vall
is.na(vall)
is.nan(vall)
is.null(vall)
is.infinite(vall)
is.finite(vall)
```
 
Sim, √© possivel criar um vetor com valores especiais.
Pelas fun√ß√µes de verifica√ß√£o de tipos especiais √© poss√≠vel identificar a qual tipo especial a vari√°vel se aplica e quando excutadas com uma variavel que √© um vetor a fun√ß√£o retorma a verifica√ß√£o de todos os elementos do vetor.
 
## Experimento com Data e Hora

Fa√ßam o seguinte experiento, analizem e comentem o resultado:

```{r exercicio9}

dia_texto <- "28/09/2017 T 18:51:30"
dia_date <- as.Date(dia_texto,format="%d/%m/%Y T %H:%M:%S",tz="America/Sao_Paulo")
dia.time1 <- as.POSIXct(dia_texto,format="%d/%m/%Y T %H:%M:%S",tz="America/Sao_Paulo")
dia.time2 <- as.POSIXlt(dia_texto,format="%d/%m/%Y T %H:%M:%S",tz="America/Sao_Paulo")

dia_date
dia.time1
dia.time2

unclass(dia_date)
unclass(dia.time1)
unclass(dia.time2)
#dia.time1$year
dia.time2$year
```

**O que a fun√ß√£o ‚Äúunclass‚Äô faz?**
Ela faz uma c√≥pia do objeto retirando seu atributo de classe e permitindo assim que seja exibido todos os atributos que compoe o objeto e n√£o sua impress√£o defaut.

**Qual a diferen√ßa entre os objetos dia.time1 e dia.time2?**
O objeto dia.time1 foi construido a classe POSIXct que cria uma data armazenando apenas a quantidade de segundos do dia 01/01/1970 at√© a data desejada. J√° o dia.time2 foi construida com a classe POSIXlt que lista informa√ß√µes detalhadas de uma data como ano, m√™s, dia, hora. minuto...
A classe POSIXct √© mais utilizada por ocupar mesmo espa√ßo na mem√≥ria.

## Exerc√≠cios Lubridate

Lubridate √© um pacote espec√≠fico para manipula√ß√£o de datas muito utilizado pelos cientistas de dados devido a facilidades que proporciona para tratamento de variaveis relacionadas ao tempo.

```{r lubridate}
#install.packages("lubridate")
library("lubridate")
```

1. Criar uma duration com 260 segundos
2. Criar uma duration com 260 minutos e divida-a por 60
3. Criar uma duration de 1 dia e subtraia uma duration de 60 minutos
4. Criar uma duration de 12 dias, 5 horas e 10 minutos

```{r exercicio10}
d260s = dseconds(x = 260)
d260m = dminutes(x = 260)/60
d1d = ddays(x = 1) - dminutes(x = 60)
#a quarta quest√£o pode ser feita por soma
d12dhm = ddays(x = 12) + dhours(x = 5) + dminutes(x = 10)
#ou com uma √∫nica duration com todos os dados
d12dhm2 = duration(day = 12, hour = 5, minute = 10)
```
5. Calcular a Black Friday de 2018:

   O Black Friday acontece 1 dias depois do dia de a√ß√£o de gra√ßas americadno, que √© celebrado na quarta quinta-feira de novembro.
   
   - Crie uma vari√°vel representando 1-nov-2018
   - Verifique que dia da semana √© 1-nov
   - Adicione a quantidade necess√°ria para chegar na quinta feira e adicione em uma segunda vari√°vel
   - Adicione 3 semanas.
   - Testar para 2019, 2020 e 2021
   
```{r exercicio11}

bf = function(ano) {
  nov01 = dmy(paste("01", "11", ano, sep = "/"))
  wday(nov01)
  black.friday = nov01
  while(wday(black.friday) != 5) {
    black.friday = black.friday + ddays(x = 1)
  }
  black.friday = black.friday + dweeks(x = 3) + ddays(x = 1)
  black.friday
}

black.friday.2018 = bf(2018)
black.friday.2018

black.friday.2019 = bf(2019)
black.friday.2019

black.friday.2020 = bf(2020)
black.friday.2020

black.friday.2021 = bf(2021)
black.friday.2021
```

## Exerc√≠cios com seq√ºencias

**1. Crie uma vari√°vel my_seq com 30 valores entre 5 e 10**
```{r}
my_seq = seq(5, 10, length.out = 30)
```

**2. Veja o help da fun√ß√£o `:`**
Segundo o help, a fun√ß√£o ":" √© equivalente a interse√ß√£o entre dois n√∫meros, ou seja from:to = seq(from, to)

**3. Qual a diferen√ßa das instru√ß√µes**
    pi:10
    10:pi
`pi:10` gera um vetor com n√∫meros com casas decimais em ordem crescente entre pi e 10. Neste caso o tamanho do vetor √© igual ao limite superior, no caso 10.

`10:pi` gera um vetor de n√∫meros inteiros com 7 posi√ß√µes em ordem decrescente. Ou seja, o tamanho do vetor neste caso √© igual a diferen√ßa entre o n√∫mero inicial e o final, desconsiderando as casas decimais.

**4. Como consultar o tamanho do vetor my_seq**
A fun√ß√£o length pode ser usada para checar o tamanho de um vetor
```{r exercicio12}
length(my_seq)
```

**5. Como fazer uma sequencia que acompanhe o tamanho do vetor my_seq?**
Uma sequ√™ncia que acompanhe o tamanho de um vetor pode ser criada de duas maneiras, utilizando o param√™tro `along.with` na fun√ß√£o `seq` ou utilizando a fun√ß√£o `seq_along`. As duas formas trar√£o o mesmo resultado como evid√™nciado abaixo. 

```{r exercicio13}
seq1 = seq(along.with = my_seq)
seq1

seq2 = seq_along(my_seq)
seq2
```