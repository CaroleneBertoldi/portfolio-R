---
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## ExercÃ­cios RMarkdown - 01

Criar um arquivo .Rmd
Configurar output para html ou notebook (que Ã© html)



## ExercÃ­cios sobre Special Values

1. Criar 5 variÃ¡veis. Cada uma com um tipo dos valores especiais (+Inf e âInf)
2. Tentar criar um vetor com as 5 variÃ¡veis.
   Foi possÃ­vel?
3. Verificar os valores das variÃ¡veis e vetor atravÃ©s das funÃ§Ãµes

```{r exercicio8}
v1 = NA
v2 = NaN
v3 = NULL
v4 = Inf
v5 = -Inf

vall = c(v1, v2, v3, v4, v5)

#V1
is.na(v1)
is.nan(v1)
is.null(v1)
is.infinite(v1)
is.finite(v1)

#V2
is.na(v2)
is.nan(v2)
is.null(v2)
is.infinite(v2)
is.finite(v2)

#V3
is.na(v3)
is.nan(v3)
is.null(v3)
is.infinite(v3)
is.finite(v3)

#V4
is.na(v4)
is.nan(v4)
is.null(v4)
is.infinite(v4)
is.finite(v4)

#V5
is.na(v5)
is.nan(v5)
is.null(v5)
is.infinite(v5)
is.finite(v5)

#Vall
is.na(vall)
is.nan(vall)
is.null(vall)
is.infinite(vall)
is.finite(vall)
```
 
Sim, Ã© possivel criar um vetor com valores especiais.
Pelas funÃ§Ãµes de verificaÃ§Ã£o de tipos especiais Ã© possÃ­vel identificar a qual tipo especial a variÃ¡vel se aplica e quando excutadas com uma variavel que Ã© um vetor a funÃ§Ã£o retorma a verificaÃ§Ã£o de todos os elementos do vetor.
 
## Experimento com Data e Hora

FaÃ§am o seguinte experiento, analizem e comentem o resultado:

```{r exercicio9}

dia_texto <- "28/09/2017 T 18:51:30"
dia_date <- as.Date(dia_texto,format="%d/%m/%Y T %H:%M:%S",tz="America/Sao_Paulo")
dia.time1 <- as.POSIXct(dia_texto,format="%d/%m/%Y T %H:%M:%S",tz="America/Sao_Paulo")
dia.time2 <- as.POSIXlt(dia_texto,format="%d/%m/%Y T %H:%M:%S",tz="America/Sao_Paulo")

dia_date
dia.time1
dia.time2

unclass(dia_date)
unclass(dia.time1)
unclass(dia.time2)
#dia.time1$year
dia.time2$year
```

**O que a funÃ§Ã£o âunclassâ faz?**
Ela faz uma cÃ³pia do objeto retirando seu atributo de classe e permitindo assim que seja exibido todos os atributos que compoe o objeto e nÃ£o sua impressÃ£o defaut.

**Qual a diferenÃ§a entre os objetos dia.time1 e dia.time2?**
O objeto dia.time1 foi construido a classe POSIXct que cria uma data armazenando apenas a quantidade de segundos do dia 01/01/1970 atÃ© a data desejada. JÃ¡ o dia.time2 foi construida com a classe POSIXlt que lista informaÃ§Ãµes detalhadas de uma data como ano, mÃªs, dia, hora. minuto...
A classe POSIXct Ã© mais utilizada por ocupar mesmo espaÃ§o na memÃ³ria.

## ExercÃ­cios Lubridate

Lubridate Ã© um pacote especÃ­fico para manipulaÃ§Ã£o de datas muito utilizado pelos cientistas de dados devido a facilidades que proporciona para tratamento de variaveis relacionadas ao tempo.

```{r lubridate}
#install.packages("lubridate")
library("lubridate")
```

1. Criar uma duration com 260 segundos
2. Criar uma duration com 260 minutos e divida-a por 60
3. Criar uma duration de 1 dia e subtraia uma duration de 60 minutos
4. Criar uma duration de 12 dias, 5 horas e 10 minutos

```{r exercicio10}
d260s = dseconds(x = 260)
d260m = dminutes(x = 260)/60
d1d = ddays(x = 1) - dminutes(x = 60)
#a quarta questÃ£o pode ser feita por soma
d12dhm = ddays(x = 12) + dhours(x = 5) + dminutes(x = 10)
#ou com uma Ãºnica duration com todos os dados
d12dhm2 = duration(day = 12, hour = 5, minute = 10)
```
5. Calcular a Black Friday de 2018:

   O Black Friday acontece 1 dias depois do dia de aÃ§Ã£o de graÃ§as americadno, que Ã© celebrado na quarta quinta-feira de novembro.
   
   - Crie uma variÃ¡vel representando 1-nov-2018
   - Verifique que dia da semana Ã© 1-nov
   - Adicione a quantidade necessÃ¡ria para chegar na quinta feira e adicione em uma segunda variÃ¡vel
   - Adicione 3 semanas.
   - Testar para 2019, 2020 e 2021
   
```{r exercicio11}

bf = function(ano) {
  nov01 = dmy(paste("01", "11", ano, sep = "/"))
  wday(nov01)
  black.friday = nov01
  while(wday(black.friday) != 5) {
    black.friday = black.friday + ddays(x = 1)
  }
  black.friday = black.friday + dweeks(x = 3) + ddays(x = 1)
  black.friday
}

black.friday.2018 = bf(2018)
black.friday.2018

black.friday.2019 = bf(2019)
black.friday.2019

black.friday.2020 = bf(2020)
black.friday.2020

black.friday.2021 = bf(2021)
black.friday.2021
```

## ExercÃ­cios com seqÃ¼encias

**1. Crie uma variÃ¡vel my_seq com 30 valores entre 5 e 10**
```{r}
my_seq = seq(5, 10, length.out = 30)
```

**2. Veja o help da funÃ§Ã£o `:`**
Segundo o help, a funÃ§Ã£o ":" Ã© equivalente a interseÃ§Ã£o entre dois nÃºmeros, ou seja from:to = seq(from, to)

**3. Qual a diferenÃ§a das instruÃ§Ãµes**
    pi:10
    10:pi
`pi:10` gera um vetor com nÃºmeros com casas decimais em ordem crescente entre pi e 10. Neste caso o tamanho do vetor Ã© igual ao limite superior, no caso 10.

`10:pi` gera um vetor de nÃºmeros inteiros com 7 posiÃ§Ãµes em ordem decrescente. Ou seja, o tamanho do vetor neste caso Ã© igual a diferenÃ§a entre o nÃºmero inicial e o final, desconsiderando as casas decimais.

**4. Como consultar o tamanho do vetor my_seq**
A funÃ§Ã£o length pode ser usada para checar o tamanho de um vetor
```{r exercicio12}
length(my_seq)
```

**5. Como fazer uma sequencia que acompanhe o tamanho do vetor my_seq?**
Uma sequÃªncia que acompanhe o tamanho de um vetor pode ser criada de duas maneiras, utilizando o paramÃªtro `along.with` na funÃ§Ã£o `seq` ou utilizando a funÃ§Ã£o `seq_along`. As duas formas trarÃ£o o mesmo resultado como evidÃªnciado abaixo. 

```{r exercicio13}
seq1 = seq(along.with = my_seq)
seq1

seq2 = seq_along(my_seq)
seq2
```